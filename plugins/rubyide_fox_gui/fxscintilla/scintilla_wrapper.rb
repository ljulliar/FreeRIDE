## ***** WARNING...THIS FILE IS GENERATED BY FROM SCINTILLA.IFACE
## *****           DO NOT MODIFY...MODIFY SCINTILLA.RB INSTEAD

module Scintilla
  ##
  ## First line may be used for shbang

  ## This file defines the interface to Scintilla

  ## Copyright 1998-2003 by Neil Hodgson <neilh@scintilla.org>

  ## ******* License for Scintilla and SciTE 
  ## http://scintilla.sourceforge.net/License.txt
  ## Copyright 1998-2003 by Neil Hodgson <neilh@scintilla.org>

  ## All Rights Reserved 

  ## Permission to use, copy, modify, and distribute this software and its 
  ## documentation for any purpose and without fee is hereby granted, 
  ## provided that the above copyright notice appear in all copies and that 
  ## both that copyright notice and this permission notice appear in 
  ## supporting documentation. 

  ## NEIL HODGSON DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
  ## SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
  ## AND FITNESS, IN NO EVENT SHALL NEIL HODGSON BE LIABLE FOR ANY 
  ## SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES 
  ## WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, 
  ## WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER 
  ## TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE 
  ## OR PERFORMANCE OF THIS SOFTWARE. 

  ## A line starting with ## is a pure comment and should be stripped by readers.
  ## A line starting with #! is for future shbang use
  ## A line starting with # followed by a space is a documentation comment and refers
  ## to the next feature definition.

  ## Each feature is defined by a line starting with fun, get, set, val or evt.
  ##     cat -> start a category
  ##     fun -> a function
  ##     get -> a property get function
  ##     set -> a property set function
  ##     val -> definition of a constant
  ##     evt -> an event
  ##     enu -> associate an enumeration with a set of vals with a prefix
  ##     lex -> associate a lexer with the lexical classes it produces
  ##
  ## All other feature names should be ignored. They may be defined in the future.
  ## A property may have a set function, a get function or both. Each will have
  ## "Get" or "Set" in their names and the corresponding name will have the obvious switch.
  ## A property may be subscripted, in which case the first parameter is the subscript.
  ## fun, get, and set features have a strict syntax:
  ## <featureType><ws><returnType><ws><name>[=<number](<param>,<param>)
  ## param is <paramType><ws><paramName>[=<value>]
  ## Additional white space is allowed between elements.
  ## The syntax for evt is <featureType><ws><returnType><ws><name>[=<number]([<param>[,<param>]*])
  ## Feature names that contain an underscore are defined by Windows, so in these
  ## cases, using the Windows definition is preferred where available.
  ## The feature numbers are stable so features will not be renumbered.
  ## Features may be removed but they will go through a period of deprecation
  ## before removal which is signalled by moving them into the Deprecated category.
  ##
  ## enu has the syntax enu<ws><enumeration>=<prefix>[<ws><prefix>]* where all the val
  ## features in this file starting with a given <prefix> are considered part of the
  ## enumeration.
  ##
  ## lex has the syntax lex<ws><name>=<lexerVal><ws><prefix>[<ws><prefix>]*
  ## where name is a reasonably capitalised (Python, XML) identifier or UI name,
  ## lexerVal is the val used to specify the lexer, and the list of prefixes is similar
  ## to enu. The name may not be the same as that used within the lexer so the lexerVal
  ## should be used to tie these entities together.

  ## Types:
  ##     void
  ##     int
  ##     bool -> integer, 1=true, 0=false
  ##     position -> integer position in a document
  ##     colour -> colour integer containing red, green and blue bytes.
  ##     string -> pointer to const character
  ##     stringresult -> pointer to character
  ##     cells -> pointer to array of cells, each cell containing a style byte and character byte
  ##     textrange -> range of a min and a max position with an output string
  ##     findtext -> searchrange, text -> foundposition
  ##     keymod -> integer containing key in low half and modifiers in high half
  ##     formatrange
  ## Types no longer used:
  ##     findtextex -> searchrange
  ##     charrange -> range of a min and a max position
  ##     charrangeresult -> like charrange, but output param
  ##     countedstring
  ##     point -> x,y
  ##     pointresult  -> like point, but output param
  ##     rectangle -> left,top,right,bottom
  ## Client code should ignore definitions containing types it does not understand, except
  ## for possibly #defining the constants

  ## String arguments may contain NUL ('\0') characters where the calls provide a length
  ## argument and retrieve NUL characters. All retrieved strings except for those retrieved
  ## by GetLine also have a NUL appended but client code should calculate the size that
  ## will be returned rather than relying upon the NUL whenever possible. Allow for the
  ## extra NUL character when allocating buffers.


  ################################################
  ## For Scintilla.h
  INVALID_POSITION = -1
  ##
  # Define start of Scintilla messages to be greater than all edit (EM_*) messages
  # as many EM_ messages can be used although that use is deprecated.
  SCI_START = 2000
  SCI_OPTIONAL_START = 3000
  SCI_LEXER_START = 4000

  ##
  # Add text to the document.
  def add_text( text )
    send_message(2001, text.length, text)
  end


  ##
  # Add array of cells to document.
  def add_styled_text( length , c )
    return (send_message(2002, length, c))
  end

  ##
  # Insert string at a position.
  def insert_text( pos , text )
    return (send_message(2003, pos, text))
  end

  ##
  # Delete all text in the document.
  def clear_all
    return (send_message(2004, 0, 0))
  end

  ##
  # Set all style bytes to 0, remove all folding information.
  def clear_document_style
    return (send_message(2005, 0, 0))
  end

  ##
  # The number of characters in the document.
  def get_length
    return (send_message(2006, 0, 0))
  end
  alias :length :get_length

  ##
  # Returns the character byte at the position.
  def get_char_at( pos )
    return (send_message(2007, pos, 0))
  end
  alias :char_at :get_char_at

  ##
  # Returns the position of the caret.
  def get_current_pos
    return (send_message(2008, 0, 0))
  end
  alias :current_pos :get_current_pos

  ##
  # Returns the position of the opposite end of the selection to the caret.
  def get_anchor
    return (send_message(2009, 0, 0))
  end
  alias :anchor :get_anchor

  ##
  # Returns the style byte at the position.
  def get_style_at( pos )
    return (send_message(2010, pos, 0))
  end
  alias :style_at :get_style_at

  ##
  # Redoes the next action on the undo history.
  def redo
    return (send_message(2011, 0, 0))
  end

  ##
  # Choose between collecting actions into the undo
  # history and discarding them.
  def set_undo_collection( collectUndo )
    return (send_message(2012, ( collectUndo ? 1 : 0 ), 0))
  end
  alias :undo_collection= :set_undo_collection

  ##
  # Select all the text in the document.
  def select_all
    return (send_message(2013, 0, 0))
  end

  ##
  # Remember the current position in the undo history as the position
  # at which the document was saved.
  def set_save_point
    return (send_message(2014, 0, 0))
  end

  ##
  # Retrieve a buffer of cells.
  # Returns the number of bytes in the buffer not including terminating nulls.
  def get_styled_text( tr )
    return (send_message(2015, 0, tr))
  end

  ##
  # Are there any redoable actions in the undo history?
  def can_redo
    return (send_message(2016, 0, 0)==1 ? true : false)
  end

  ##
  # Retrieve the line number at which a particular marker is located.
  def marker_line_from_handle( handle )
    return (send_message(2017, handle, 0))
  end

  ##
  # Delete a marker.
  def marker_delete_handle( handle )
    return (send_message(2018, handle, 0))
  end

  ##
  # Is undo history being collected?
  def get_undo_collection
    return (send_message(2019, 0, 0)==1 ? true : false)
  end
  alias :undo_collection? :get_undo_collection

  SCWS_INVISIBLE = 0
  SCWS_VISIBLEALWAYS = 1
  SCWS_VISIBLEAFTERINDENT = 2

  ##
  # Are white space characters currently visible?
  # Returns one of SCWS_* constants.
  def get_view_ws
    return (send_message(2020, 0, 0))
  end
  alias :view_ws :get_view_ws

  ##
  # Make white space characters invisible, always visible or visible outside indentation.
  def set_view_ws( viewWS )
    return (send_message(2021, viewWS, 0))
  end
  alias :view_ws= :set_view_ws

  ##
  # Find the position from a point within the window.
  def position_from_point( x , y )
    return (send_message(2022, x, y))
  end

  ##
  # Find the position from a point within the window but return
  # INVALID_POSITION if not close to text.
  def position_from_point_close( x , y )
    return (send_message(2023, x, y))
  end

  ##
  # Set caret to start of a line and ensure it is visible.
  def goto_line( line )
    return (send_message(2024, line, 0))
  end

  ##
  # Set caret to a position and ensure it is visible.
  def goto_pos( pos )
    return (send_message(2025, pos, 0))
  end

  ##
  # Set the selection anchor to a position. The anchor is the opposite
  # end of the selection from the caret.
  def set_anchor( posAnchor )
    return (send_message(2026, posAnchor, 0))
  end
  alias :anchor= :set_anchor

  ##
  # Retrieve the text of the line containing the caret.
  # Returns the index of the caret on the line.
  def get_cur_line( length )
    buffer = ' '*length
    send_message(2027, length, buffer)
    return buffer
  end

  ##
  # Retrieve the position of the last correctly styled character.
  def get_end_styled
    return (send_message(2028, 0, 0))
  end
  alias :end_styled :get_end_styled

  SC_EOL_CRLF = 0
  SC_EOL_CR = 1
  SC_EOL_LF = 2

  ##
  # Convert all line endings in the document to one mode.
  def convert_eo_ls( eolMode )
    return (send_message(2029, eolMode, 0))
  end

  ##
  # Retrieve the current end of line mode - one of CRLF, CR, or LF.
  def get_eol_mode
    return (send_message(2030, 0, 0))
  end
  alias :eol_mode :get_eol_mode

  ##
  # Set the current end of line mode.
  def set_eol_mode( eolMode )
    return (send_message(2031, eolMode, 0))
  end
  alias :eol_mode= :set_eol_mode

  ##
  # Set the current styling position to pos and the styling mask to mask.
  # The styling mask can be used to protect some bits in each styling byte from modification.
  def start_styling( pos , mask )
    return (send_message(2032, pos, mask))
  end

  ##
  # Change style from current styling position for length characters to a style
  # and move the current styling position to after this newly styled segment.
  def set_styling( length , style )
    return (send_message(2033, length, style))
  end

  ##
  # Is drawing done first into a buffer or direct to the screen?
  def get_buffered_draw
    return (send_message(2034, 0, 0)==1 ? true : false)
  end
  alias :buffered_draw? :get_buffered_draw

  ##
  # If drawing is buffered then each line of text is drawn into a bitmap buffer
  # before drawing it to the screen to avoid flicker.
  def set_buffered_draw( buffered )
    return (send_message(2035, ( buffered ? 1 : 0 ), 0))
  end
  alias :buffered_draw= :set_buffered_draw

  ##
  # Change the visible size of a tab to be a multiple of the width of a space character.
  def set_tab_width( tabWidth )
    return (send_message(2036, tabWidth, 0))
  end
  alias :tab_width= :set_tab_width

  ##
  # Retrieve the visible size of a tab.
  def get_tab_width
    return (send_message(2121, 0, 0))
  end
  alias :tab_width :get_tab_width

  ##
  # The SC_CP_UTF8 value can be used to enter Unicode mode.
  # This is the same value as CP_UTF8 in Windows
  SC_CP_UTF8 = 65001

  ##
  # Set the code page used to interpret the bytes of the document as characters.
  # The SC_CP_UTF8 value can be used to enter Unicode mode.
  def set_code_page( codePage )
    return (send_message(2037, codePage, 0))
  end
  alias :code_page= :set_code_page

  ##
  # In palette mode, Scintilla uses the environment's palette calls to display
  # more colours. This may lead to ugly displays.
  def set_use_palette( usePalette )
    return (send_message(2039, ( usePalette ? 1 : 0 ), 0))
  end
  alias :use_palette= :set_use_palette

  MARKER_MAX = 31
  SC_MARK_CIRCLE = 0
  SC_MARK_ROUNDRECT = 1
  SC_MARK_ARROW = 2
  SC_MARK_SMALLRECT = 3
  SC_MARK_SHORTARROW = 4
  SC_MARK_EMPTY = 5
  SC_MARK_ARROWDOWN = 6
  SC_MARK_MINUS = 7
  SC_MARK_PLUS = 8

  ##
  # Shapes used for outlining column.
  SC_MARK_VLINE = 9
  SC_MARK_LCORNER = 10
  SC_MARK_TCORNER = 11
  SC_MARK_BOXPLUS = 12
  SC_MARK_BOXPLUSCONNECTED = 13
  SC_MARK_BOXMINUS = 14
  SC_MARK_BOXMINUSCONNECTED = 15
  SC_MARK_LCORNERCURVE = 16
  SC_MARK_TCORNERCURVE = 17
  SC_MARK_CIRCLEPLUS = 18
  SC_MARK_CIRCLEPLUSCONNECTED = 19
  SC_MARK_CIRCLEMINUS = 20
  SC_MARK_CIRCLEMINUSCONNECTED = 21

  ##
  # Invisible mark that only sets the line background color.
  SC_MARK_BACKGROUND = 22
  SC_MARK_DOTDOTDOT = 23
  SC_MARK_ARROWS = 24
  SC_MARK_PIXMAP = 25

  SC_MARK_CHARACTER = 10000

  ##
  # Markers used for outlining column.
  SC_MARKNUM_FOLDEREND = 25
  SC_MARKNUM_FOLDEROPENMID = 26
  SC_MARKNUM_FOLDERMIDTAIL = 27
  SC_MARKNUM_FOLDERTAIL = 28
  SC_MARKNUM_FOLDERSUB = 29
  SC_MARKNUM_FOLDER = 30
  SC_MARKNUM_FOLDEROPEN = 31

  SC_MASK_FOLDERS = 0xFE000000

  ##
  # Set the symbol used for a particular marker number.
  def marker_define( markerNumber , markerSymbol )
    return (send_message(2040, markerNumber, markerSymbol))
  end

  ##
  # Set the foreground colour used for a particular marker number.
  def marker_set_fore( markerNumber , fore )
    return (send_message(2041, markerNumber, fore.to_i))
  end

  ##
  # Set the background colour used for a particular marker number.
  def marker_set_back( markerNumber , back )
    return (send_message(2042, markerNumber, back.to_i))
  end

  ##
  # Add a marker to a line, returning an ID which can be used to find or delete the marker.
  def marker_add( line , markerNumber )
    return (send_message(2043, line, markerNumber))
  end

  ##
  # Delete a marker from a line.
  def marker_delete( line , markerNumber )
    return (send_message(2044, line, markerNumber))
  end

  ##
  # Delete all markers with a particular number from all lines.
  def marker_delete_all( markerNumber )
    return (send_message(2045, markerNumber, 0))
  end

  ##
  # Get a bit mask of all the markers set on a line.
  def marker_get( line )
    return (send_message(2046, line, 0))
  end

  ##
  # Find the next line after lineStart that includes a marker in mask.
  def marker_next( lineStart , markerMask )
    return (send_message(2047, lineStart, markerMask))
  end

  ##
  # Find the previous line before lineStart that includes a marker in mask.
  def marker_previous( lineStart , markerMask )
    return (send_message(2048, lineStart, markerMask))
  end

  ##
  # Define a marker from a pixmap.
  def marker_define_pixmap( markerNumber , pixmap )
    return (send_message(2049, markerNumber, pixmap))
  end

  SC_MARGIN_SYMBOL = 0
  SC_MARGIN_NUMBER = 1

  ##
  # Set a margin to be either numeric or symbolic.
  def set_margin_type_n( margin , marginType )
    return (send_message(2240, margin, marginType))
  end

  ##
  # Retrieve the type of a margin.
  def get_margin_type_n( margin )
    return (send_message(2241, margin, 0))
  end
  alias :margin_type_n :get_margin_type_n

  ##
  # Set the width of a margin to a width expressed in pixels.
  def set_margin_width_n( margin , pixelWidth )
    return (send_message(2242, margin, pixelWidth))
  end

  ##
  # Retrieve the width of a margin in pixels.
  def get_margin_width_n( margin )
    return (send_message(2243, margin, 0))
  end
  alias :margin_width_n :get_margin_width_n

  ##
  # Set a mask that determines which markers are displayed in a margin.
  def set_margin_mask_n( margin , mask )
    return (send_message(2244, margin, mask))
  end

  ##
  # Retrieve the marker mask of a margin.
  def get_margin_mask_n( margin )
    return (send_message(2245, margin, 0))
  end
  alias :margin_mask_n :get_margin_mask_n

  ##
  # Make a margin sensitive or insensitive to mouse clicks.
  def set_margin_sensitive_n( margin , sensitive )
    return (send_message(2246, margin, ( sensitive ? 1 : 0 )))
  end

  ##
  # Retrieve the mouse click sensitivity of a margin.
  def get_margin_sensitive_n( margin )
    return (send_message(2247, margin, 0)==1 ? true : false)
  end
  alias :margin_sensitive_n? :get_margin_sensitive_n

  ##
  # Styles in range 32..37 are predefined for parts of the UI and are not used as normal styles.
  # Styles 38 and 39 are for future use.
  STYLE_DEFAULT = 32
  STYLE_LINENUMBER = 33
  STYLE_BRACELIGHT = 34
  STYLE_BRACEBAD = 35
  STYLE_CONTROLCHAR = 36
  STYLE_INDENTGUIDE = 37
  STYLE_LASTPREDEFINED = 39
  STYLE_MAX = 127

  ##
  # Character set identifiers are used in StyleSetCharacterSet.
  # The values are the same as the Windows *_CHARSET values.
  SC_CHARSET_ANSI = 0
  SC_CHARSET_DEFAULT = 1
  SC_CHARSET_BALTIC = 186
  SC_CHARSET_CHINESEBIG5 = 136
  SC_CHARSET_EASTEUROPE = 238
  SC_CHARSET_GB2312 = 134
  SC_CHARSET_GREEK = 161
  SC_CHARSET_HANGUL = 129
  SC_CHARSET_MAC = 77
  SC_CHARSET_OEM = 255
  SC_CHARSET_RUSSIAN = 204
  SC_CHARSET_SHIFTJIS = 128
  SC_CHARSET_SYMBOL = 2
  SC_CHARSET_TURKISH = 162
  SC_CHARSET_JOHAB = 130
  SC_CHARSET_HEBREW = 177
  SC_CHARSET_ARABIC = 178
  SC_CHARSET_VIETNAMESE = 163
  SC_CHARSET_THAI = 222

  ##
  # Clear all the styles and make equivalent to the global default style.
  def set_style_clear_all
    return (send_message(2050, 0, 0))
  end

  ##
  # Set the foreground colour of a style.
  def set_style_set_fore( style , fore )
    return (send_message(2051, style, fore.to_i))
  end

  ##
  # Set the background colour of a style.
  def set_style_set_back( style , back )
    return (send_message(2052, style, back.to_i))
  end

  ##
  # Set a style to be bold or not.
  def set_style_set_bold( style , bold )
    return (send_message(2053, style, ( bold ? 1 : 0 )))
  end

  ##
  # Set a style to be italic or not.
  def set_style_set_italic( style , italic )
    return (send_message(2054, style, ( italic ? 1 : 0 )))
  end

  ##
  # Set the size of characters of a style.
  def set_style_set_size( style , sizePoints )
    return (send_message(2055, style, sizePoints))
  end

  ##
  # Set the font of a style.
  def set_style_set_font( style , fontName )
    return (send_message(2056, style, fontName))
  end

  ##
  # Set a style to have its end of line filled or not.
  def set_style_set_eol_filled( style , filled )
    return (send_message(2057, style, ( filled ? 1 : 0 )))
  end

  ##
  # Reset the default style to its state at startup
  def style_reset_default
    return (send_message(2058, 0, 0))
  end

  ##
  # Set a style to be underlined or not.
  def set_style_set_underline( style , underline )
    return (send_message(2059, style, ( underline ? 1 : 0 )))
  end

  SC_CASE_MIXED = 0
  SC_CASE_UPPER = 1
  SC_CASE_LOWER = 2
  ##
  # Set a style to be mixed case, or to force upper or lower case.
  def set_style_set_case( style , caseForce )
    return (send_message(2060, style, caseForce))
  end

  ##
  # Set the character set of the font in a style.
  def set_style_set_character_set( style , characterSet )
    return (send_message(2066, style, characterSet))
  end

  ##
  # Set the foreground colour of the selection and whether to use this setting.
  def set_sel_fore( useSetting , fore )
    return (send_message(2067, ( useSetting ? 1 : 0 ), fore.to_i))
  end

  ##
  # Set the background colour of the selection and whether to use this setting.
  def set_sel_back( useSetting , back )
    return (send_message(2068, ( useSetting ? 1 : 0 ), back.to_i))
  end

  ##
  # Set the foreground colour of the caret.
  def set_caret_fore( fore )
    return (send_message(2069, fore.to_i, 0))
  end
  alias :caret_fore= :set_caret_fore

  ##
  # When key+modifier combination km is pressed perform msg.
  def assign_cmd_key( km , msg )
    return (send_message(2070, km, msg))
  end

  ##
  # When key+modifier combination km do nothing.
  def clear_cmd_key( km )
    return (send_message(2071, km, 0))
  end

  ##
  # Drop all key mappings.
  def clear_all_cmd_keys
    return (send_message(2072, 0, 0))
  end

  ##
  # Set the styles for a segment of the document.
  def set_styling_ex( length , styles )
    return (send_message(2073, length, styles))
  end

  ##
  # Set a style to be visible or not.
  def set_style_set_visible( style , visible )
    return (send_message(2074, style, ( visible ? 1 : 0 )))
  end

  ##
  # Get the time in milliseconds that the caret is on and off.
  def get_caret_period
    return (send_message(2075, 0, 0))
  end
  alias :caret_period :get_caret_period

  ##
  # Get the time in milliseconds that the caret is on and off. 0 = steady on.
  def set_caret_period( periodMilliseconds )
    return (send_message(2076, periodMilliseconds, 0))
  end
  alias :caret_period= :set_caret_period

  ##
  # Set the set of characters making up words for when moving or selecting by word.
  def set_word_chars( characters )
    return (send_message(2077, 0, characters))
  end

  ##
  # Start a sequence of actions that is undone and redone as a unit.
  # May be nested.
  def begin_undo_action
    return (send_message(2078, 0, 0))
  end

  ##
  # End a sequence of actions that is undone and redone as a unit.
  def end_undo_action
    return (send_message(2079, 0, 0))
  end

  INDIC_MAX = 7
  INDIC_PLAIN = 0
  INDIC_SQUIGGLE = 1
  INDIC_TT = 2
  INDIC_DIAGONAL = 3
  INDIC_STRIKE = 4
  INDIC0_MASK = 0x20
  INDIC1_MASK = 0x40
  INDIC2_MASK = 0x80
  INDICS_MASK = 0xE0

  ##
  # Set an indicator to plain, squiggle or TT.
  def set_indic_set_style( indic , style )
    return (send_message(2080, indic, style))
  end

  ##
  # Retrieve the style of an indicator.
  def get_indic_get_style( indic )
    return (send_message(2081, indic, 0))
  end
  alias :indic_get_style :get_indic_get_style

  ##
  # Set the foreground colour of an indicator.
  def set_indic_set_fore( indic , fore )
    return (send_message(2082, indic, fore.to_i))
  end

  ##
  # Retrieve the foreground colour of an indicator.
  def get_indic_get_fore( indic )
    return (send_message(2083, indic, 0))
  end
  alias :indic_get_fore :get_indic_get_fore

  ##
  # Set the foreground colour of all whitespace and whether to use this setting.
  def set_whitespace_fore( useSetting , fore )
    return (send_message(2084, ( useSetting ? 1 : 0 ), fore.to_i))
  end

  ##
  # Set the background colour of all whitespace and whether to use this setting.
  def set_whitespace_back( useSetting , back )
    return (send_message(2085, ( useSetting ? 1 : 0 ), back.to_i))
  end

  ##
  # Divide each styling byte into lexical class bits (default: 5) and indicator
  # bits (default: 3). If a lexer requires more than 32 lexical states, then this
  # is used to expand the possible states.
  def set_style_bits( bits )
    return (send_message(2090, bits, 0))
  end
  alias :style_bits= :set_style_bits

  ##
  # Retrieve number of bits in style bytes used to hold the lexical state.
  def get_style_bits
    return (send_message(2091, 0, 0))
  end
  alias :style_bits :get_style_bits

  ##
  # Used to hold extra styling information for each line.
  def set_line_state( line , state )
    return (send_message(2092, line, state))
  end

  ##
  # Retrieve the extra styling information for a line.
  def get_line_state( line )
    return (send_message(2093, line, 0))
  end
  alias :line_state :get_line_state

  ##
  # Retrieve the last line number that has line state.
  def get_max_line_state
    return (send_message(2094, 0, 0))
  end
  alias :max_line_state :get_max_line_state

  ##
  # Is the background of the line containing the caret in a different colour?
  def get_caret_line_visible
    return (send_message(2095, 0, 0)==1 ? true : false)
  end
  alias :caret_line_visible? :get_caret_line_visible

  ##
  # Display the background of the line containing the caret in a different colour.
  def set_caret_line_visible( show )
    return (send_message(2096, ( show ? 1 : 0 ), 0))
  end
  alias :caret_line_visible= :set_caret_line_visible

  ##
  # Get the colour of the background of the line containing the caret.
  def get_caret_line_back
    return (send_message(2097, 0, 0))
  end
  alias :caret_line_back :get_caret_line_back

  ##
  # Set the colour of the background of the line containing the caret.
  def set_caret_line_back( back )
    return (send_message(2098, back.to_i, 0))
  end
  alias :caret_line_back= :set_caret_line_back

  ##
  # Set a style to be changeable or not (read only).
  # Experimental feature, currently buggy.
  def set_style_set_changeable( style , changeable )
    return (send_message(2099, style, ( changeable ? 1 : 0 )))
  end

  ##
  # Display a auto-completion list.
  # The lenEntered parameter indicates how many characters before
  # the caret should be used to provide context.
  def auto_c_show( lenEntered , itemList )
    return (send_message(2100, lenEntered, itemList))
  end

  ##
  # Remove the auto-completion list from the screen.
  def auto_c_cancel
    return (send_message(2101, 0, 0))
  end

  ##
  # Is there an auto-completion list visible?
  def auto_c_active
    return (send_message(2102, 0, 0)==1 ? true : false)
  end

  ##
  # Retrieve the position of the caret when the auto-completion list was displayed.
  def auto_c_pos_start
    return (send_message(2103, 0, 0))
  end

  ##
  # User has selected an item so remove the list and insert the selection.
  def auto_c_complete
    return (send_message(2104, 0, 0))
  end

  ##
  # Define a set of character that when typed cancel the auto-completion list.
  def auto_c_stops( characterSet )
    return (send_message(2105, 0, characterSet))
  end

  ##
  # Change the separator character in the string setting up an auto-completion list.
  # Default is space but can be changed if items contain space.
  def set_auto_c_set_separator( separatorCharacter )
    return (send_message(2106, separatorCharacter, 0))
  end
  alias :auto_c_set_separator= :set_auto_c_set_separator

  ##
  # Retrieve the auto-completion list separator character.
  def get_auto_c_get_separator
    return (send_message(2107, 0, 0))
  end
  alias :auto_c_get_separator :get_auto_c_get_separator

  ##
  # Select the item in the auto-completion list that starts with a string.
  def auto_c_select( text )
    return (send_message(2108, 0, text))
  end

  ##
  # Should the auto-completion list be cancelled if the user backspaces to a
  # position before where the box was created.
  def set_auto_c_set_cancel_at_start( cancel )
    return (send_message(2110, ( cancel ? 1 : 0 ), 0))
  end
  alias :auto_c_set_cancel_at_start= :set_auto_c_set_cancel_at_start

  ##
  # Retrieve whether auto-completion cancelled by backspacing before start.
  def get_auto_c_get_cancel_at_start
    return (send_message(2111, 0, 0)==1 ? true : false)
  end
  alias :auto_c_get_cancel_at_start? :get_auto_c_get_cancel_at_start

  ##
  # Define a set of characters that when typed will cause the autocompletion to
  # choose the selected item.
  def set_auto_c_set_fill_ups( characterSet )
    return (send_message(2112, 0, characterSet))
  end

  ##
  # Should a single item auto-completion list automatically choose the item.
  def set_auto_c_set_choose_single( chooseSingle )
    return (send_message(2113, ( chooseSingle ? 1 : 0 ), 0))
  end
  alias :auto_c_set_choose_single= :set_auto_c_set_choose_single

  ##
  # Retrieve whether a single item auto-completion list automatically choose the item.
  def get_auto_c_get_choose_single
    return (send_message(2114, 0, 0)==1 ? true : false)
  end
  alias :auto_c_get_choose_single? :get_auto_c_get_choose_single

  ##
  # Set whether case is significant when performing auto-completion searches.
  def set_auto_c_set_ignore_case( ignoreCase )
    return (send_message(2115, ( ignoreCase ? 1 : 0 ), 0))
  end
  alias :auto_c_set_ignore_case= :set_auto_c_set_ignore_case

  ##
  # Retrieve state of ignore case flag.
  def get_auto_c_get_ignore_case
    return (send_message(2116, 0, 0)==1 ? true : false)
  end
  alias :auto_c_get_ignore_case? :get_auto_c_get_ignore_case

  ##
  # Display a list of strings and send notification when user chooses one.
  def user_list_show( listType , itemList )
    return (send_message(2117, listType, itemList))
  end

  ##
  # Set whether or not autocompletion is hidden automatically when nothing matches.
  def set_auto_c_set_auto_hide( autoHide )
    return (send_message(2118, ( autoHide ? 1 : 0 ), 0))
  end
  alias :auto_c_set_auto_hide= :set_auto_c_set_auto_hide

  ##
  # Retrieve whether or not autocompletion is hidden automatically when nothing matches.
  def get_auto_c_get_auto_hide
    return (send_message(2119, 0, 0)==1 ? true : false)
  end
  alias :auto_c_get_auto_hide? :get_auto_c_get_auto_hide

  ##
  # Set whether or not autocompletion deletes any word characters
  # after the inserted text upon completion.
  def set_auto_c_set_drop_rest_of_word( dropRestOfWord )
    return (send_message(2270, ( dropRestOfWord ? 1 : 0 ), 0))
  end
  alias :auto_c_set_drop_rest_of_word= :set_auto_c_set_drop_rest_of_word

  ##
  # Retrieve whether or not autocompletion deletes any word characters
  # after the inserted text upon completion.
  def get_auto_c_get_drop_rest_of_word
    return (send_message(2271, 0, 0)==1 ? true : false)
  end
  alias :auto_c_get_drop_rest_of_word? :get_auto_c_get_drop_rest_of_word

  ##
  # Set the number of spaces used for one level of indentation.
  def set_indent( indentSize )
    return (send_message(2122, indentSize, 0))
  end
  alias :indent= :set_indent

  ##
  # Retrieve indentation size.
  def get_indent
    return (send_message(2123, 0, 0))
  end
  alias :indent :get_indent

  ##
  # Indentation will only use space characters if useTabs is false, otherwise
  # it will use a combination of tabs and spaces.
  def set_use_tabs( useTabs )
    return (send_message(2124, ( useTabs ? 1 : 0 ), 0))
  end
  alias :use_tabs= :set_use_tabs

  ##
  # Retrieve whether tabs will be used in indentation.
  def get_use_tabs
    return (send_message(2125, 0, 0)==1 ? true : false)
  end
  alias :use_tabs? :get_use_tabs

  ##
  # Change the indentation of a line to a number of columns.
  def set_line_indentation( line , indentSize )
    return (send_message(2126, line, indentSize))
  end

  ##
  # Retrieve the number of columns that a line is indented.
  def get_line_indentation( line )
    return (send_message(2127, line, 0))
  end
  alias :line_indentation :get_line_indentation

  ##
  # Retrieve the position before the first non indentation character on a line.
  def get_line_indent_position( line )
    return (send_message(2128, line, 0))
  end
  alias :line_indent_position :get_line_indent_position

  ##
  # Retrieve the column number of a position, taking tab width into account.
  def get_column( pos )
    return (send_message(2129, pos, 0))
  end
  alias :column :get_column

  ##
  # Show or hide the horizontal scroll bar.
  def set_h_scroll_bar( show )
    return (send_message(2130, ( show ? 1 : 0 ), 0))
  end
  alias :h_scroll_bar= :set_h_scroll_bar

  ##
  # Is the horizontal scroll bar visible?
  def get_h_scroll_bar
    return (send_message(2131, 0, 0)==1 ? true : false)
  end
  alias :h_scroll_bar? :get_h_scroll_bar

  ##
  # Show or hide indentation guides.
  def set_indentation_guides( show )
    return (send_message(2132, ( show ? 1 : 0 ), 0))
  end
  alias :indentation_guides= :set_indentation_guides

  ##
  # Are the indentation guides visible?
  def get_indentation_guides
    return (send_message(2133, 0, 0)==1 ? true : false)
  end
  alias :indentation_guides? :get_indentation_guides

  ##
  # Set the highlighted indentation guide column.
  # 0 = no highlighted guide.
  def set_highlight_guide( column )
    return (send_message(2134, column, 0))
  end
  alias :highlight_guide= :set_highlight_guide

  ##
  # Get the highlighted indentation guide column.
  def get_highlight_guide
    return (send_message(2135, 0, 0))
  end
  alias :highlight_guide :get_highlight_guide

  ##
  # Get the position after the last visible characters on a line.
  def get_line_end_position( line )
    return (send_message(2136, line, 0))
  end
  alias :line_end_position :get_line_end_position

  ##
  # Get the code page used to interpret the bytes of the document as characters.
  def get_code_page
    return (send_message(2137, 0, 0))
  end
  alias :code_page :get_code_page

  ##
  # Get the foreground colour of the caret.
  def get_caret_fore
    return (send_message(2138, 0, 0))
  end
  alias :caret_fore :get_caret_fore

  ##
  # In palette mode?
  def get_use_palette
    return (send_message(2139, 0, 0)==1 ? true : false)
  end
  alias :use_palette? :get_use_palette

  ##
  # In read-only mode?
  def get_read_only
    return (send_message(2140, 0, 0)==1 ? true : false)
  end
  alias :read_only? :get_read_only

  ##
  # Sets the position of the caret.
  def set_current_pos( pos )
    return (send_message(2141, pos, 0))
  end
  alias :current_pos= :set_current_pos

  ##
  # Sets the position that starts the selection - this becomes the anchor.
  def set_selection_start( pos )
    return (send_message(2142, pos, 0))
  end
  alias :selection_start= :set_selection_start

  ##
  # Returns the position at the start of the selection.
  def get_selection_start
    return (send_message(2143, 0, 0))
  end
  alias :selection_start :get_selection_start

  ##
  # Sets the position that ends the selection - this becomes the currentPosition.
  def set_selection_end( pos )
    return (send_message(2144, pos, 0))
  end
  alias :selection_end= :set_selection_end

  ##
  # Returns the position at the end of the selection.
  def get_selection_end
    return (send_message(2145, 0, 0))
  end
  alias :selection_end :get_selection_end

  ##
  # Sets the print magnification added to the point size of each style for printing.
  def set_print_magnification( magnification )
    return (send_message(2146, magnification, 0))
  end
  alias :print_magnification= :set_print_magnification

  ##
  # Returns the print magnification.
  def get_print_magnification
    return (send_message(2147, 0, 0))
  end
  alias :print_magnification :get_print_magnification

  ##
  # PrintColourMode - use same colours as screen.
  SC_PRINT_NORMAL = 0
  ##
  # PrintColourMode - invert the light value of each style for printing.
  SC_PRINT_INVERTLIGHT = 1
  ##
  # PrintColourMode - force black text on white background for printing.
  SC_PRINT_BLACKONWHITE = 2
  ##
  # PrintColourMode - text stays coloured, but all background is forced to be white for printing.
  SC_PRINT_COLOURONWHITE = 3
  ##
  # PrintColourMode - only the default-background is forced to be white for printing.
  SC_PRINT_COLOURONWHITEDEFAULTBG = 4

  ##
  # Modify colours when printing for clearer printed text.
  def set_print_colour_mode( mode )
    return (send_message(2148, mode, 0))
  end
  alias :print_colour_mode= :set_print_colour_mode

  ##
  # Returns the print colour mode.
  def get_print_colour_mode
    return (send_message(2149, 0, 0))
  end
  alias :print_colour_mode :get_print_colour_mode

  SCFIND_WHOLEWORD = 2
  SCFIND_MATCHCASE = 4
  SCFIND_WORDSTART = 0x00100000
  SCFIND_REGEXP = 0x00200000

  ##
  # Find some text in the document.
  def find_text( flags , ft )
    return (send_message(2150, flags, ft))
  end

  ##
  # On Windows, will draw the document into a display context such as a printer.
  def format_range( draw , fr )
    return (send_message(2151, ( draw ? 1 : 0 ), fr))
  end

  ##
  # Retrieve the display line at the top of the display.
  def get_first_visible_line
    return (send_message(2152, 0, 0))
  end
  alias :first_visible_line :get_first_visible_line

  ##
  # Retrieve the contents of a line.
  # Returns the length of the line.
  def get_line( line )
    len = send_message(2153, line, '')
    buffer = ' '*len
    send_message(2153, line, buffer)
    return buffer
  end

  ##
  # Returns the number of lines in the document. There is always at least one.
  def get_line_count
    return (send_message(2154, 0, 0))
  end
  alias :line_count :get_line_count

  ##
  # Sets the size in pixels of the left margin.
  def set_margin_left( pixelWidth )
    return (send_message(2155, 0, pixelWidth))
  end

  ##
  # Returns the size in pixels of the left margin.
  def get_margin_left
    return (send_message(2156, 0, 0))
  end
  alias :margin_left :get_margin_left

  ##
  # Sets the size in pixels of the right margin.
  def set_margin_right( pixelWidth )
    return (send_message(2157, 0, pixelWidth))
  end

  ##
  # Returns the size in pixels of the right margin.
  def get_margin_right
    return (send_message(2158, 0, 0))
  end
  alias :margin_right :get_margin_right

  ##
  # Is the document different from when it was last saved?
  def get_modify
    return (send_message(2159, 0, 0)==1 ? true : false)
  end
  alias :modify? :get_modify

  ##
  # Select a range of text.
  def set_sel( start , finish )
    return (send_message(2160, start, finish))
  end

  ##
  # Retrieve the selected text.
  # Return the length of the text.
  def get_sel_text
    len = send_message(2161, 0, '')
    buffer = ' '*len
    send_message(2161, len, buffer)
    return buffer
  end

  ##
  # Retrieve a range of text.
  # Return the length of the text.
  def get_text_range( tr )
    return (send_message(2162, 0, tr))
  end

  ##
  # Draw the selection in normal style or with selection highlighted.
  def hide_selection( normal )
    return (send_message(2163, ( normal ? 1 : 0 ), 0))
  end

  ##
  # Retrieve the x value of the point in the window where a position is displayed.
  def point_x_from_position( pos )
    return (send_message(2164, 0, pos))
  end

  ##
  # Retrieve the y value of the point in the window where a position is displayed.
  def point_y_from_position( pos )
    return (send_message(2165, 0, pos))
  end

  ##
  # Retrieve the line containing a position.
  def line_from_position( pos )
    return (send_message(2166, pos, 0))
  end

  ##
  # Retrieve the position at the start of a line.
  def position_from_line( line )
    return (send_message(2167, line, 0))
  end

  ##
  # Scroll horizontally and vertically.
  def line_scroll( columns , lines )
    return (send_message(2168, columns, lines))
  end

  ##
  # Ensure the caret is visible.
  def scroll_caret
    return (send_message(2169, 0, 0))
  end

  ##
  # Replace the selected text with the argument text.
  def replace_sel( text )
    return (send_message(2170, 0, text))
  end

  ##
  # Set to read only or read write.
  def set_read_only( readOnly )
    return (send_message(2171, ( readOnly ? 1 : 0 ), 0))
  end
  alias :read_only= :set_read_only

  ##
  # Null operation.
  def null
    return (send_message(2172, 0, 0))
  end

  ##
  # Will a paste succeed?
  def can_paste
    return (send_message(2173, 0, 0)==1 ? true : false)
  end

  ##
  # Are there any undoable actions in the undo history?
  def can_undo
    return (send_message(2174, 0, 0)==1 ? true : false)
  end

  ##
  # Delete the undo history.
  def empty_undo_buffer
    return (send_message(2175, 0, 0))
  end

  ##
  # Undo one action in the undo history.
  def undo
    return (send_message(2176, 0, 0))
  end

  ##
  # Cut the selection to the clipboard.
  def cut
    return (send_message(2177, 0, 0))
  end

  ##
  # Copy the selection to the clipboard.
  def copy
    return (send_message(2178, 0, 0))
  end

  ##
  # Paste the contents of the clipboard into the document replacing the selection.
  def paste
    return (send_message(2179, 0, 0))
  end

  ##
  # Clear the selection.
  def clear
    return (send_message(2180, 0, 0))
  end

  ##
  # Replace the contents of the document with the argument text.
  def set_text( text )
    return (send_message(2181, 0, text))
  end

  ##
  # Retrieve all the text in the document.
  # Returns number of characters retrieved.
  def get_text( length )
    buffer = ' '*length
    send_message(2182, length, buffer)
    return buffer
  end

  ##
  # Retrieve the number of characters in the document.
  def get_text_length
    return (send_message(2183, 0, 0))
  end
  alias :text_length :get_text_length

  ##
  # Retrieve a pointer to a function that processes messages for this Scintilla.
  def get_direct_function
    return (send_message(2184, 0, 0))
  end
  alias :direct_function :get_direct_function

  ##
  # Retrieve a pointer value to use as the first argument when calling
  # the function returned by GetDirectFunction.
  def get_direct_pointer
    return (send_message(2185, 0, 0))
  end
  alias :direct_pointer :get_direct_pointer

  ##
  # Set to overtype (true) or insert mode.
  def set_overtype( overtype )
    return (send_message(2186, ( overtype ? 1 : 0 ), 0))
  end
  alias :overtype= :set_overtype

  ##
  # Returns true if overtype mode is active otherwise false is returned.
  def get_overtype
    return (send_message(2187, 0, 0)==1 ? true : false)
  end
  alias :overtype? :get_overtype

  ##
  # Set the width of the insert mode caret.
  def set_caret_width( pixelWidth )
    return (send_message(2188, pixelWidth, 0))
  end
  alias :caret_width= :set_caret_width

  ##
  # Returns the width of the insert mode caret.
  def get_caret_width
    return (send_message(2189, 0, 0))
  end
  alias :caret_width :get_caret_width

  ##
  # Sets the position that starts the target which is used for updating the
  # document without affecting the scroll position.
  def set_target_start( pos )
    return (send_message(2190, pos, 0))
  end
  alias :target_start= :set_target_start

  ##
  # Get the position that starts the target.
  def get_target_start
    return (send_message(2191, 0, 0))
  end
  alias :target_start :get_target_start

  ##
  # Sets the position that ends the target which is used for updating the
  # document without affecting the scroll position.
  def set_target_end( pos )
    return (send_message(2192, pos, 0))
  end
  alias :target_end= :set_target_end

  ##
  # Get the position that ends the target.
  def get_target_end
    return (send_message(2193, 0, 0))
  end
  alias :target_end :get_target_end

  ##
  # Replace the target text with the argument text.
  # Text is counted so it can contain nulls.
  # Returns the length of the replacement text.
  def replace_target( text )
    send_message(2194, text.length, text)
  end


  ##
  # Replace the target text with the argument text after \d processing.
  # Text is counted so it can contain nulls.
  # Looks for \d where d is between 1 and 9 and replaces these with the strings
  # matched in the last search operation which were surrounded by \( and \).
  # Returns the length of the replacement text including any change
  # caused by processing the \d patterns.
  def replace_target_re( text )
    send_message(2195, text.length, text)
  end


  ##
  # Search for a counted string in the target and set the target to the found
  # range. Text is counted so it can contain nulls.
  # Returns length of range or -1 for failure in which case target is not moved.
  def search_in_target( text )
    send_message(2197, text.length, text)
  end


  ##
  # Set the search flags used by SearchInTarget.
  def set_search_flags( flags )
    return (send_message(2198, flags, 0))
  end
  alias :search_flags= :set_search_flags

  ##
  # Get the search flags used by SearchInTarget.
  def get_search_flags
    return (send_message(2199, 0, 0))
  end
  alias :search_flags :get_search_flags

  ##
  # Show a call tip containing a definition near position pos.
  def call_tip_show( pos , definition )
    return (send_message(2200, pos, definition))
  end

  ##
  # Remove the call tip from the screen.
  def call_tip_cancel
    return (send_message(2201, 0, 0))
  end

  ##
  # Is there an active call tip?
  def call_tip_active
    return (send_message(2202, 0, 0)==1 ? true : false)
  end

  ##
  # Retrieve the position where the caret was before displaying the call tip.
  def call_tip_pos_start
    return (send_message(2203, 0, 0))
  end

  ##
  # Highlight a segment of the definition.
  def call_tip_set_hlt( start , finish )
    return (send_message(2204, start, finish))
  end

  ##
  # Set the background colour for the call tip.
  def set_call_tip_set_back( back )
    return (send_message(2205, back.to_i, 0))
  end
  alias :call_tip_set_back= :set_call_tip_set_back

  ##
  # Find the display line of a document line taking hidden lines into account.
  def visible_from_doc_line( line )
    return (send_message(2220, line, 0))
  end

  ##
  # Find the document line of a display line taking hidden lines into account.
  def doc_line_from_visible( lineDisplay )
    return (send_message(2221, lineDisplay, 0))
  end

  SC_FOLDLEVELBASE = 0x400
  SC_FOLDLEVELWHITEFLAG = 0x1000
  SC_FOLDLEVELHEADERFLAG = 0x2000
  SC_FOLDLEVELNUMBERMASK = 0x0FFF

  ##
  # Set the fold level of a line.
  # This encodes an integer level along with flags indicating whether the
  # line is a header and whether it is effectively white space.
  def set_fold_level( line , level )
    return (send_message(2222, line, level))
  end

  ##
  # Retrieve the fold level of a line.
  def get_fold_level( line )
    return (send_message(2223, line, 0))
  end
  alias :fold_level :get_fold_level

  ##
  # Find the last child line of a header line.
  def get_last_child( line , level )
    return (send_message(2224, line, level))
  end
  alias :last_child :get_last_child

  ##
  # Find the parent line of a child line.
  def get_fold_parent( line )
    return (send_message(2225, line, 0))
  end
  alias :fold_parent :get_fold_parent

  ##
  # Make a range of lines visible.
  def show_lines( lineStart , lineEnd )
    return (send_message(2226, lineStart, lineEnd))
  end

  ##
  # Make a range of lines invisible.
  def hide_lines( lineStart , lineEnd )
    return (send_message(2227, lineStart, lineEnd))
  end

  ##
  # Is a line visible?
  def get_line_visible( line )
    return (send_message(2228, line, 0)==1 ? true : false)
  end
  alias :line_visible? :get_line_visible

  ##
  # Show the children of a header line.
  def set_fold_expanded( line , expanded )
    return (send_message(2229, line, ( expanded ? 1 : 0 )))
  end

  ##
  # Is a header line expanded?
  def get_fold_expanded( line )
    return (send_message(2230, line, 0)==1 ? true : false)
  end
  alias :fold_expanded? :get_fold_expanded

  ##
  # Switch a header line between expanded and contracted.
  def toggle_fold( line )
    return (send_message(2231, line, 0))
  end

  ##
  # Ensure a particular line is visible by expanding any header line hiding it.
  def ensure_visible( line )
    return (send_message(2232, line, 0))
  end

  ##
  # Set some debugging options for folding.
  def set_fold_flags( flags )
    return (send_message(2233, flags, 0))
  end

  ##
  # Ensure a particular line is visible by expanding any header line hiding it.
  # Use the currently set visibility policy to determine which range to display.
  def ensure_visible_enforce_policy( line )
    return (send_message(2234, line, 0))
  end

  ##
  # Sets whether a tab pressed when caret is within indentation indents.
  def set_tab_indents( tabIndents )
    return (send_message(2260, ( tabIndents ? 1 : 0 ), 0))
  end
  alias :tab_indents= :set_tab_indents

  ##
  # Does a tab pressed when caret is within indentation indent?
  def get_tab_indents
    return (send_message(2261, 0, 0)==1 ? true : false)
  end
  alias :tab_indents? :get_tab_indents

  ##
  # Sets whether a backspace pressed when caret is within indentation unindents.
  def set_back_space_un_indents( bsUnIndents )
    return (send_message(2262, ( bsUnIndents ? 1 : 0 ), 0))
  end
  alias :back_space_un_indents= :set_back_space_un_indents

  ##
  # Does a backspace pressed when caret is within indentation unindent?
  def get_back_space_un_indents
    return (send_message(2263, 0, 0)==1 ? true : false)
  end
  alias :back_space_un_indents? :get_back_space_un_indents

  SC_TIME_FOREVER = 10000000

  ##
  # Sets the time the mouse must sit still to generate a mouse dwell event.
  def set_mouse_dwell_time( periodMilliseconds )
    return (send_message(2264, periodMilliseconds, 0))
  end
  alias :mouse_dwell_time= :set_mouse_dwell_time

  ##
  # Retrieve the time the mouse must sit still to generate a mouse dwell event.
  def get_mouse_dwell_time
    return (send_message(2265, 0, 0))
  end
  alias :mouse_dwell_time :get_mouse_dwell_time

  ##
  # Get position of start of word.
  def word_start_position( pos , onlyWordCharacters )
    return (send_message(2266, pos, ( onlyWordCharacters ? 1 : 0 )))
  end

  ##
  # Get position of end of word.
  def word_end_position( pos , onlyWordCharacters )
    return (send_message(2267, pos, ( onlyWordCharacters ? 1 : 0 )))
  end

  SC_WRAP_NONE = 0
  SC_WRAP_WORD = 1

  ##
  # Sets whether text is word wrapped.
  def set_wrap_mode( mode )
    return (send_message(2268, mode, 0))
  end
  alias :wrap_mode= :set_wrap_mode

  ##
  # Retrieve whether text is word wrapped.
  def get_wrap_mode
    return (send_message(2269, 0, 0))
  end
  alias :wrap_mode :get_wrap_mode

  SC_CACHE_NONE = 0
  SC_CACHE_CARET = 1
  SC_CACHE_PAGE = 2
  SC_CACHE_DOCUMENT = 3

  ##
  # Sets the degree of caching of layout information.
  def set_layout_cache( mode )
    return (send_message(2272, mode, 0))
  end
  alias :layout_cache= :set_layout_cache

  ##
  # Retrieve the degree of caching of layout information.
  def get_layout_cache
    return (send_message(2273, 0, 0))
  end
  alias :layout_cache :get_layout_cache

  ##
  # Sets the document width assumed for scrolling.
  def set_scroll_width( pixelWidth )
    return (send_message(2274, pixelWidth, 0))
  end
  alias :scroll_width= :set_scroll_width

  ##
  # Retrieve the document width assumed for scrolling.
  def get_scroll_width
    return (send_message(2275, 0, 0))
  end
  alias :scroll_width :get_scroll_width

  ##
  # Measure the pixel width of some text in a particular style.
  # Nul terminated text argument.
  # Does not handle tab or control characters.
  def text_width( style , text )
    return (send_message(2276, style, text))
  end

  ##
  # Sets the scroll range so that maximum scroll position has
  # the last line at the bottom of the view (default).
  # Setting this to false allows scrolling one page below the last line.
  def set_end_at_last_line( endAtLastLine )
    return (send_message(2277, ( endAtLastLine ? 1 : 0 ), 0))
  end
  alias :end_at_last_line= :set_end_at_last_line

  ##
  # Retrieve whether the maximum scroll position has the last
  # line at the bottom of the view.
  def get_end_at_last_line
    return (send_message(2278, 0, 0))
  end
  alias :end_at_last_line :get_end_at_last_line

  ##
  # Retrieve the height of a particular line of text in pixels.
  def text_height( line )
    return (send_message(2279, line, 0))
  end

  ##
  # Show or hide the vertical scroll bar.
  def set_v_scroll_bar( show )
    return (send_message(2280, ( show ? 1 : 0 ), 0))
  end
  alias :v_scroll_bar= :set_v_scroll_bar

  ##
  # Is the vertical scroll bar visible?
  def get_v_scroll_bar
    return (send_message(2281, 0, 0)==1 ? true : false)
  end
  alias :v_scroll_bar? :get_v_scroll_bar

  ##
  # Append a string to the end of the document without changing the selection.
  def append_text( text )
    send_message(2282, text.length, text)
  end


  ##
  ## New messages go here

  ## Start of key messages
  # Move caret down one line.
  def line_down
    return (send_message(2300, 0, 0))
  end

  ##
  # Move caret down one line extending selection to new caret position.
  def line_down_extend
    return (send_message(2301, 0, 0))
  end

  ##
  # Move caret up one line.
  def line_up
    return (send_message(2302, 0, 0))
  end

  ##
  # Move caret up one line extending selection to new caret position.
  def line_up_extend
    return (send_message(2303, 0, 0))
  end

  ##
  # Move caret left one character.
  def char_left
    return (send_message(2304, 0, 0))
  end

  ##
  # Move caret left one character extending selection to new caret position.
  def char_left_extend
    return (send_message(2305, 0, 0))
  end

  ##
  # Move caret right one character.
  def char_right
    return (send_message(2306, 0, 0))
  end

  ##
  # Move caret right one character extending selection to new caret position.
  def char_right_extend
    return (send_message(2307, 0, 0))
  end

  ##
  # Move caret left one word.
  def word_left
    return (send_message(2308, 0, 0))
  end

  ##
  # Move caret left one word extending selection to new caret position.
  def word_left_extend
    return (send_message(2309, 0, 0))
  end

  ##
  # Move caret right one word.
  def word_right
    return (send_message(2310, 0, 0))
  end

  ##
  # Move caret right one word extending selection to new caret position.
  def word_right_extend
    return (send_message(2311, 0, 0))
  end

  ##
  # Move caret to first position on line.
  def home
    return (send_message(2312, 0, 0))
  end

  ##
  # Move caret to first position on line extending selection to new caret position.
  def home_extend
    return (send_message(2313, 0, 0))
  end

  ##
  # Move caret to last position on line.
  def line_end
    return (send_message(2314, 0, 0))
  end

  ##
  # Move caret to last position on line extending selection to new caret position.
  def line_end_extend
    return (send_message(2315, 0, 0))
  end

  ##
  # Move caret to first position in document.
  def document_start
    return (send_message(2316, 0, 0))
  end

  ##
  # Move caret to first position in document extending selection to new caret position.
  def document_start_extend
    return (send_message(2317, 0, 0))
  end

  ##
  # Move caret to last position in document.
  def document_end
    return (send_message(2318, 0, 0))
  end

  ##
  # Move caret to last position in document extending selection to new caret position.
  def document_end_extend
    return (send_message(2319, 0, 0))
  end

  ##
  # Move caret one page up.
  def page_up
    return (send_message(2320, 0, 0))
  end

  ##
  # Move caret one page up extending selection to new caret position.
  def page_up_extend
    return (send_message(2321, 0, 0))
  end

  ##
  # Move caret one page down.
  def page_down
    return (send_message(2322, 0, 0))
  end

  ##
  # Move caret one page down extending selection to new caret position.
  def page_down_extend
    return (send_message(2323, 0, 0))
  end

  ##
  # Switch from insert to overtype mode or the reverse.
  def edit_toggle_overtype
    return (send_message(2324, 0, 0))
  end

  ##
  # Cancel any modes such as call tip or auto-completion list display.
  def cancel
    return (send_message(2325, 0, 0))
  end

  ##
  # Delete the selection or if no selection, the character before the caret.
  def delete_back
    return (send_message(2326, 0, 0))
  end

  ##
  # If selection is empty or all on one line replace the selection with a tab character.
  # If more than one line selected, indent the lines.
  def tab
    return (send_message(2327, 0, 0))
  end

  ##
  # Dedent the selected lines.
  def back_tab
    return (send_message(2328, 0, 0))
  end

  ##
  # Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
  def new_line
    return (send_message(2329, 0, 0))
  end

  ##
  # Insert a Form Feed character.
  def form_feed
    return (send_message(2330, 0, 0))
  end

  ##
  # Move caret to before first visible character on line.
  # If already there move to first character on line.
  def vc_home
    return (send_message(2331, 0, 0))
  end

  ##
  # Like VCHome but extending selection to new caret position.
  def vc_home_extend
    return (send_message(2332, 0, 0))
  end

  ##
  # Magnify the displayed text by increasing the sizes by 1 point.
  def zoom_in
    return (send_message(2333, 0, 0))
  end

  ##
  # Make the displayed text smaller by decreasing the sizes by 1 point.
  def zoom_out
    return (send_message(2334, 0, 0))
  end

  ##
  # Delete the word to the left of the caret.
  def del_word_left
    return (send_message(2335, 0, 0))
  end

  ##
  # Delete the word to the right of the caret.
  def del_word_right
    return (send_message(2336, 0, 0))
  end

  ##
  # Cut the line containing the caret.
  def line_cut
    return (send_message(2337, 0, 0))
  end

  ##
  # Delete the line containing the caret.
  def line_delete
    return (send_message(2338, 0, 0))
  end

  ##
  # Switch the current line with the previous.
  def line_transpose
    return (send_message(2339, 0, 0))
  end

  ##
  # Transform the selection to lower case.
  def lower_case
    return (send_message(2340, 0, 0))
  end

  ##
  # Transform the selection to upper case.
  def upper_case
    return (send_message(2341, 0, 0))
  end

  ##
  # Scroll the document down, keeping the caret visible.
  def line_scroll_down
    return (send_message(2342, 0, 0))
  end

  ##
  # Scroll the document up, keeping the caret visible.
  def line_scroll_up
    return (send_message(2343, 0, 0))
  end

  ##
  # Delete the selection or if no selection, the character before the caret.
  # Will not delete the character before at the start of a line.
  def delete_back_not_line
    return (send_message(2344, 0, 0))
  end

  ##
  # Move caret to first position on display line.
  def home_display
    return (send_message(2345, 0, 0))
  end

  ##
  # Move caret to first position on display line extending selection to
  # new caret position.
  def home_display_extend
    return (send_message(2346, 0, 0))
  end

  ##
  # Move caret to last position on display line.
  def line_end_display
    return (send_message(2347, 0, 0))
  end

  ##
  # Move caret to last position on display line extending selection to new
  # caret position.
  def line_end_display_extend
    return (send_message(2348, 0, 0))
  end

  ##
  # Move the caret inside current view if it's not there already.
  def move_caret_inside_view
    return (send_message(2401, 0, 0))
  end

  ##
  # How many characters are on a line, not including end of line characters?
  def line_length( line )
    return (send_message(2350, line, 0))
  end

  ##
  # Highlight the characters at two positions.
  def brace_highlight( pos1 , pos2 )
    return (send_message(2351, pos1, pos2))
  end

  ##
  # Highlight the character at a position indicating there is no matching brace.
  def brace_bad_light( pos )
    return (send_message(2352, pos, 0))
  end

  ##
  # Find the position of a matching brace or INVALID_POSITION if no match.
  def brace_match( pos )
    return (send_message(2353, pos, 0))
  end

  ##
  # Are the end of line characters visible?
  def get_view_eol
    return (send_message(2355, 0, 0)==1 ? true : false)
  end
  alias :view_eol? :get_view_eol

  ##
  # Make the end of line characters visible or invisible.
  def set_view_eol( visible )
    return (send_message(2356, ( visible ? 1 : 0 ), 0))
  end
  alias :view_eol= :set_view_eol

  ##
  # Retrieve a pointer to the document object.
  def get_doc_pointer
    return (send_message(2357, 0, 0))
  end
  alias :doc_pointer :get_doc_pointer

  ##
  # Change the document object used.
  def set_doc_pointer( pointer )
    return (send_message(2358, 0, pointer))
  end

  ##
  # Set which document modification events are sent to the container.
  def set_mod_event_mask( mask )
    return (send_message(2359, mask, 0))
  end
  alias :mod_event_mask= :set_mod_event_mask

  EDGE_NONE = 0
  EDGE_LINE = 1
  EDGE_BACKGROUND = 2

  ##
  # Retrieve the column number which text should be kept within.
  def get_edge_column
    return (send_message(2360, 0, 0))
  end
  alias :edge_column :get_edge_column

  ##
  # Set the column number of the edge.
  # If text goes past the edge then it is highlighted.
  def set_edge_column( column )
    return (send_message(2361, column, 0))
  end
  alias :edge_column= :set_edge_column

  ##
  # Retrieve the edge highlight mode.
  def get_edge_mode
    return (send_message(2362, 0, 0))
  end
  alias :edge_mode :get_edge_mode

  ##
  # The edge may be displayed by a line (EDGE_LINE) or by highlighting text that
  # goes beyond it (EDGE_BACKGROUND) or not displayed at all (EDGE_NONE).
  def set_edge_mode( mode )
    return (send_message(2363, mode, 0))
  end
  alias :edge_mode= :set_edge_mode

  ##
  # Retrieve the colour used in edge indication.
  def get_edge_colour
    return (send_message(2364, 0, 0))
  end
  alias :edge_colour :get_edge_colour

  ##
  # Change the colour used in edge indication.
  def set_edge_colour( edgeColour )
    return (send_message(2365, edgeColour.to_i, 0))
  end
  alias :edge_colour= :set_edge_colour

  ##
  # Sets the current caret position to be the search anchor.
  def search_anchor
    return (send_message(2366, 0, 0))
  end

  ##
  # Find some text starting at the search anchor.
  # Does not ensure the selection is visible.
  def search_next( flags , text )
    return (send_message(2367, flags, text))
  end

  ##
  # Find some text starting at the search anchor and moving backwards.
  # Does not ensure the selection is visible.
  def search_prev( flags , text )
    return (send_message(2368, flags, text))
  end

  ##
  # Retrieves the number of lines completely visible.
  def get_lines_on_screen
    return (send_message(2370, 0, 0))
  end
  alias :lines_on_screen :get_lines_on_screen

  ##
  # Set whether a pop up menu is displayed automatically when the user presses
  # the wrong mouse button.
  def use_pop_up( allowPopUp )
    return (send_message(2371, ( allowPopUp ? 1 : 0 ), 0))
  end

  ##
  # Is the selection rectangular? The alternative is the more common stream selection.
  def get_selection_is_rectangle
    return (send_message(2372, 0, 0)==1 ? true : false)
  end
  alias :selection_is_rectangle? :get_selection_is_rectangle

  ##
  # Set the zoom level. This number of points is added to the size of all fonts.
  # It may be positive to magnify or negative to reduce.
  def set_zoom( zoom )
    return (send_message(2373, zoom, 0))
  end
  alias :zoom= :set_zoom
  ##
  # Retrieve the zoom level.
  def get_zoom
    return (send_message(2374, 0, 0))
  end
  alias :zoom :get_zoom

  ##
  # Create a new document object.
  # Starts with reference count of 1 and not selected into editor.
  def create_document
    return (send_message(2375, 0, 0))
  end
  ##
  # Extend life of document.
  def add_ref_document( doc )
    return (send_message(2376, 0, doc))
  end
  ##
  # Release a reference to the document, deleting document if it fades to black.
  def release_document( doc )
    return (send_message(2377, 0, doc))
  end

  ##
  # Get which document modification events are sent to the container.
  def get_mod_event_mask
    return (send_message(2378, 0, 0))
  end
  alias :mod_event_mask :get_mod_event_mask

  ##
  # Change internal focus flag.
  def set_focus( focus )
    return (send_message(2380, ( focus ? 1 : 0 ), 0))
  end
  alias :focus= :set_focus
  ##
  # Get internal focus flag.
  def get_focus
    return (send_message(2381, 0, 0)==1 ? true : false)
  end
  alias :focus? :get_focus

  ##
  # Change error status - 0 = OK.
  def set_status( statusCode )
    return (send_message(2382, statusCode, 0))
  end
  alias :status= :set_status
  ##
  # Get error status.
  def get_status
    return (send_message(2383, 0, 0))
  end
  alias :status :get_status

  ##
  # Set whether the mouse is captured when its button is pressed.
  def set_mouse_down_captures( captures )
    return (send_message(2384, ( captures ? 1 : 0 ), 0))
  end
  alias :mouse_down_captures= :set_mouse_down_captures
  ##
  # Get whether mouse gets captured.
  def get_mouse_down_captures
    return (send_message(2385, 0, 0)==1 ? true : false)
  end
  alias :mouse_down_captures? :get_mouse_down_captures

  SC_CURSORNORMAL = -1
  SC_CURSORWAIT = 4
  ##
  # Sets the cursor to one of the SC_CURSOR* values.
  def set_cursor( cursorType )
    return (send_message(2386, cursorType, 0))
  end
  alias :cursor= :set_cursor
  ##
  # Get cursor type.
  def get_cursor
    return (send_message(2387, 0, 0))
  end
  alias :cursor :get_cursor

  ##
  # Change the way control characters are displayed:
  # If symbol is < 32, keep the drawn way, else, use the given character.
  def set_control_char_symbol( symbol )
    return (send_message(2388, symbol, 0))
  end
  alias :control_char_symbol= :set_control_char_symbol
  ##
  # Get the way control characters are displayed.
  def get_control_char_symbol
    return (send_message(2389, 0, 0))
  end
  alias :control_char_symbol :get_control_char_symbol

  ##
  # Move to the previous change in capitalisation.
  def word_part_left
    return (send_message(2390, 0, 0))
  end
  ##
  # Move to the previous change in capitalisation extending selection
  # to new caret position.
  def word_part_left_extend
    return (send_message(2391, 0, 0))
  end
  ##
  # Move to the change next in capitalisation.
  def word_part_right
    return (send_message(2392, 0, 0))
  end
  ##
  # Move to the next change in capitalisation extending selection
  # to new caret position.
  def word_part_right_extend
    return (send_message(2393, 0, 0))
  end

  ##
  # Constants for use with SetVisiblePolicy, similar to SetCaretPolicy.
  VISIBLE_SLOP = 0x01
  VISIBLE_STRICT = 0x04
  ##
  # Set the way the display area is determined when a particular line
  # is to be moved to by Find, FindNext, GotoLine, etc.
  def set_visible_policy( visiblePolicy , visibleSlop )
    return (send_message(2394, visiblePolicy, visibleSlop))
  end

  ##
  # Delete back from the current position to the start of the line.
  def del_line_left
    return (send_message(2395, 0, 0))
  end

  ##
  # Delete forwards from the current position to the end of the line.
  def del_line_right
    return (send_message(2396, 0, 0))
  end

  ##
  # Get and Set the xOffset (ie, horizonal scroll position).
  def set_x_offset( newOffset )
    return (send_message(2397, newOffset, 0))
  end
  alias :x_offset= :set_x_offset
  def get_x_offset
    return (send_message(2398, 0, 0))
  end
  alias :x_offset :get_x_offset

  ##
  # Set the last x chosen value to be the caret x position
  def choose_caret_x
    return (send_message(2399, 0, 0))
  end

  ##
  # Set the focus to this Scintilla widget.
  # GTK+ Specific.
  def grab_focus
    return (send_message(2400, 0, 0))
  end

  ##
  # Caret policy, used by SetXCaretPolicy and SetYCaretPolicy.
  # If CARET_SLOP is set, we can define a slop value: caretSlop.
  # This value defines an unwanted zone (UZ) where the caret is... unwanted.
  # This zone is defined as a number of pixels near the vertical margins,
  # and as a number of lines near the horizontal margins.
  # By keeping the caret away from the edges, it is seen within its context,
  # so it is likely that the identifier that the caret is on can be completely seen,
  # and that the current line is seen with some of the lines following it which are
  # often dependent on that line.
  CARET_SLOP = 0x01
  ##
  # If CARET_STRICT is set, the policy is enforced... strictly.
  # The caret is centred on the display if slop is not set,
  # and cannot go in the UZ if slop is set.
  CARET_STRICT = 0x04
  ##
  # If CARET_JUMPS is set, the display is moved more energetically
  # so the caret can move in the same direction longer before the policy is applied again.
  CARET_JUMPS = 0x10
  ##
  # If CARET_EVEN is not set, instead of having symmetrical UZs,
  # the left and bottom UZs are extended up to right and top UZs respectively.
  # This way, we favour the displaying of useful information: the begining of lines,
  # where most code reside, and the lines after the caret, eg. the body of a function.
  CARET_EVEN = 0x08

  ##
  # Set the way the caret is kept visible when going sideway.
  # The exclusion zone is given in pixels.
  def set_x_caret_policy( caretPolicy , caretSlop )
    return (send_message(2402, caretPolicy, caretSlop))
  end

  ##
  # Set the way the line the caret is on is kept visible.
  # The exclusion zone is given in lines.
  def set_y_caret_policy( caretPolicy , caretSlop )
    return (send_message(2403, caretPolicy, caretSlop))
  end

  ##
  # Start notifying the container of all key presses and commands.
  def start_record
    return (send_message(3001, 0, 0))
  end

  ##
  # Stop notifying the container of all key presses and commands.
  def stop_record
    return (send_message(3002, 0, 0))
  end

  ##
  # Set the lexing language of the document.
  def set_lexer( lexer )
    return (send_message(4001, lexer, 0))
  end
  alias :lexer= :set_lexer

  ##
  # Retrieve the lexing language of the document.
  def get_lexer
    return (send_message(4002, 0, 0))
  end
  alias :lexer :get_lexer

  ##
  # Colourise a segment of the document using the current lexing language.
  def colourise( start , finish )
    return (send_message(4003, start, finish))
  end

  ##
  # Set up a value that may be used by a lexer for some optional feature.
  def set_property( key , value )
    return (send_message(4004, key, value))
  end

  ##
  # Set up the key words used by the lexer.
  def set_key_words( keywordSet , keyWords )
    return (send_message(4005, keywordSet, keyWords))
  end

  ##
  # Set the lexing language of the document based on string name.
  def set_lexer_language( language )
    return (send_message(4006, 0, language))
  end

  ##
  # Notifications
  # Type of modification and the action which caused the modification.
  # These are defined as a bit mask to make it easy to specify which notifications are wanted.
  # One bit is set from each of SC_MOD_* and SC_PERFORMED_*.
  SC_MOD_INSERTTEXT = 0x1
  SC_MOD_DELETETEXT = 0x2
  SC_MOD_CHANGESTYLE = 0x4
  SC_MOD_CHANGEFOLD = 0x8
  SC_PERFORMED_USER = 0x10
  SC_PERFORMED_UNDO = 0x20
  SC_PERFORMED_REDO = 0x40
  SC_LASTSTEPINUNDOREDO = 0x100
  SC_MOD_CHANGEMARKER = 0x200
  SC_MOD_BEFOREINSERT = 0x400
  SC_MOD_BEFOREDELETE = 0x800
  SC_MODEVENTMASKALL = 0xF77

  ##
  # For compatibility, these go through the COMMAND notification rather than NOTIFY
  # and should have had exactly the same values as the EN_* constants.
  # Unfortunately the SETFOCUS and KILLFOCUS are flipped over from EN_*
  # As clients depend on these constants, this will not be changed.
  SCEN_CHANGE = 768
  SCEN_SETFOCUS = 512
  SCEN_KILLFOCUS = 256

  ##
  # Symbolic key codes and modifier flags.
  # ASCII and other printable characters below 256.
  # Extended keys above 300.

  SCK_DOWN = 300
  SCK_UP = 301
  SCK_LEFT = 302
  SCK_RIGHT = 303
  SCK_HOME = 304
  SCK_END = 305
  SCK_PRIOR = 306
  SCK_NEXT = 307
  SCK_DELETE = 308
  SCK_INSERT = 309
  SCK_ESCAPE = 7
  SCK_BACK = 8
  SCK_TAB = 9
  SCK_RETURN = 13
  SCK_ADD = 310
  SCK_SUBTRACT = 311
  SCK_DIVIDE = 312

  SCMOD_SHIFT = 1
  SCMOD_CTRL = 2
  SCMOD_ALT = 4

  ##
  ################################################
  # For SciLexer.h
  SCLEX_CONTAINER = 0
  SCLEX_NULL = 1
  SCLEX_PYTHON = 2
  SCLEX_CPP = 3
  SCLEX_HTML = 4
  SCLEX_XML = 5
  SCLEX_PERL = 6
  SCLEX_SQL = 7
  SCLEX_VB = 8
  SCLEX_PROPERTIES = 9
  SCLEX_ERRORLIST = 10
  SCLEX_MAKEFILE = 11
  SCLEX_BATCH = 12
  SCLEX_XCODE = 13
  SCLEX_LATEX = 14
  SCLEX_LUA = 15
  SCLEX_DIFF = 16
  SCLEX_CONF = 17
  SCLEX_PASCAL = 18
  SCLEX_AVE = 19
  SCLEX_ADA = 20
  SCLEX_LISP = 21
  SCLEX_RUBY = 22
  SCLEX_EIFFEL = 23
  SCLEX_EIFFELKW = 24
  SCLEX_TCL = 25
  SCLEX_NNCRONTAB = 26
  SCLEX_BULLANT = 27
  SCLEX_VBSCRIPT = 28
  SCLEX_ASP = 29
  SCLEX_PHP = 30
  SCLEX_BAAN = 31
  SCLEX_MATLAB = 32
  SCLEX_SCRIPTOL = 33
  SCLEX_ASM = 34
  SCLEX_CPPNOCASE = 35
  SCLEX_FORTRAN = 36
  SCLEX_F77 = 37

  ##
  # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
  # value assigned in sequence from SCLEX_AUTOMATIC+1.
  SCLEX_AUTOMATIC = 1000
  ##
  # Lexical states for SCLEX_PYTHON
  SCE_P_DEFAULT = 0
  SCE_P_COMMENTLINE = 1
  SCE_P_NUMBER = 2
  SCE_P_STRING = 3
  SCE_P_CHARACTER = 4
  SCE_P_WORD = 5
  SCE_P_TRIPLE = 6
  SCE_P_TRIPLEDOUBLE = 7
  SCE_P_CLASSNAME = 8
  SCE_P_DEFNAME = 9
  SCE_P_OPERATOR = 10
  SCE_P_IDENTIFIER = 11
  SCE_P_COMMENTBLOCK = 12
  SCE_P_STRINGEOL = 13
  ##
  # Lexical states for SCLEX_CPP
  SCE_C_DEFAULT = 0
  SCE_C_COMMENT = 1
  SCE_C_COMMENTLINE = 2
  SCE_C_COMMENTDOC = 3
  SCE_C_NUMBER = 4
  SCE_C_WORD = 5
  SCE_C_STRING = 6
  SCE_C_CHARACTER = 7
  SCE_C_UUID = 8
  SCE_C_PREPROCESSOR = 9
  SCE_C_OPERATOR = 10
  SCE_C_IDENTIFIER = 11
  SCE_C_STRINGEOL = 12
  SCE_C_VERBATIM = 13
  SCE_C_REGEX = 14
  SCE_C_COMMENTLINEDOC = 15
  SCE_C_WORD2 = 16
  SCE_C_COMMENTDOCKEYWORD = 17
  SCE_C_COMMENTDOCKEYWORDERROR = 18
  ##
  # Lexical states for SCLEX_HTML, SCLEX_XML
  SCE_H_DEFAULT = 0
  SCE_H_TAG = 1
  SCE_H_TAGUNKNOWN = 2
  SCE_H_ATTRIBUTE = 3
  SCE_H_ATTRIBUTEUNKNOWN = 4
  SCE_H_NUMBER = 5
  SCE_H_DOUBLESTRING = 6
  SCE_H_SINGLESTRING = 7
  SCE_H_OTHER = 8
  SCE_H_COMMENT = 9
  SCE_H_ENTITY = 10
  ##
  # XML and ASP
  SCE_H_TAGEND = 11
  SCE_H_XMLSTART = 12
  SCE_H_XMLEND = 13
  SCE_H_SCRIPT = 14
  SCE_H_ASP = 15
  SCE_H_ASPAT = 16
  SCE_H_CDATA = 17
  SCE_H_QUESTION = 18
  ##
  # More HTML
  SCE_H_VALUE = 19
  ##
  # X-Code
  SCE_H_XCCOMMENT = 20
  ##
  # SGML
  SCE_H_SGML_DEFAULT = 21
  SCE_H_SGML_COMMAND = 22
  SCE_H_SGML_1ST_PARAM = 23
  SCE_H_SGML_DOUBLESTRING = 24
  SCE_H_SGML_SIMPLESTRING = 25
  SCE_H_SGML_ERROR = 26
  SCE_H_SGML_SPECIAL = 27
  SCE_H_SGML_ENTITY = 28
  SCE_H_SGML_COMMENT = 29
  SCE_H_SGML_1ST_PARAM_COMMENT = 30
  SCE_H_SGML_BLOCK_DEFAULT = 31
  ##
  # Embedded Javascript
  SCE_HJ_START = 40
  SCE_HJ_DEFAULT = 41
  SCE_HJ_COMMENT = 42
  SCE_HJ_COMMENTLINE = 43
  SCE_HJ_COMMENTDOC = 44
  SCE_HJ_NUMBER = 45
  SCE_HJ_WORD = 46
  SCE_HJ_KEYWORD = 47
  SCE_HJ_DOUBLESTRING = 48
  SCE_HJ_SINGLESTRING = 49
  SCE_HJ_SYMBOLS = 50
  SCE_HJ_STRINGEOL = 51
  SCE_HJ_REGEX = 52
  ##
  # ASP Javascript
  SCE_HJA_START = 55
  SCE_HJA_DEFAULT = 56
  SCE_HJA_COMMENT = 57
  SCE_HJA_COMMENTLINE = 58
  SCE_HJA_COMMENTDOC = 59
  SCE_HJA_NUMBER = 60
  SCE_HJA_WORD = 61
  SCE_HJA_KEYWORD = 62
  SCE_HJA_DOUBLESTRING = 63
  SCE_HJA_SINGLESTRING = 64
  SCE_HJA_SYMBOLS = 65
  SCE_HJA_STRINGEOL = 66
  SCE_HJA_REGEX = 67
  ##
  # Embedded VBScript
  SCE_HB_START = 70
  SCE_HB_DEFAULT = 71
  SCE_HB_COMMENTLINE = 72
  SCE_HB_NUMBER = 73
  SCE_HB_WORD = 74
  SCE_HB_STRING = 75
  SCE_HB_IDENTIFIER = 76
  SCE_HB_STRINGEOL = 77
  ##
  # ASP VBScript
  SCE_HBA_START = 80
  SCE_HBA_DEFAULT = 81
  SCE_HBA_COMMENTLINE = 82
  SCE_HBA_NUMBER = 83
  SCE_HBA_WORD = 84
  SCE_HBA_STRING = 85
  SCE_HBA_IDENTIFIER = 86
  SCE_HBA_STRINGEOL = 87
  ##
  # Embedded Python
  SCE_HP_START = 90
  SCE_HP_DEFAULT = 91
  SCE_HP_COMMENTLINE = 92
  SCE_HP_NUMBER = 93
  SCE_HP_STRING = 94
  SCE_HP_CHARACTER = 95
  SCE_HP_WORD = 96
  SCE_HP_TRIPLE = 97
  SCE_HP_TRIPLEDOUBLE = 98
  SCE_HP_CLASSNAME = 99
  SCE_HP_DEFNAME = 100
  SCE_HP_OPERATOR = 101
  SCE_HP_IDENTIFIER = 102
  ##
  # ASP Python
  SCE_HPA_START = 105
  SCE_HPA_DEFAULT = 106
  SCE_HPA_COMMENTLINE = 107
  SCE_HPA_NUMBER = 108
  SCE_HPA_STRING = 109
  SCE_HPA_CHARACTER = 110
  SCE_HPA_WORD = 111
  SCE_HPA_TRIPLE = 112
  SCE_HPA_TRIPLEDOUBLE = 113
  SCE_HPA_CLASSNAME = 114
  SCE_HPA_DEFNAME = 115
  SCE_HPA_OPERATOR = 116
  SCE_HPA_IDENTIFIER = 117
  ##
  # PHP
  SCE_HPHP_DEFAULT = 118
  SCE_HPHP_HSTRING = 119
  SCE_HPHP_SIMPLESTRING = 120
  SCE_HPHP_WORD = 121
  SCE_HPHP_NUMBER = 122
  SCE_HPHP_VARIABLE = 123
  SCE_HPHP_COMMENT = 124
  SCE_HPHP_COMMENTLINE = 125
  SCE_HPHP_HSTRING_VARIABLE = 126
  SCE_HPHP_OPERATOR = 127
  ##
  # Lexical states for SCLEX_PERL
  SCE_PL_DEFAULT = 0
  SCE_PL_ERROR = 1
  SCE_PL_COMMENTLINE = 2
  SCE_PL_POD = 3
  SCE_PL_NUMBER = 4
  SCE_PL_WORD = 5
  SCE_PL_STRING = 6
  SCE_PL_CHARACTER = 7
  SCE_PL_PUNCTUATION = 8
  SCE_PL_PREPROCESSOR = 9
  SCE_PL_OPERATOR = 10
  SCE_PL_IDENTIFIER = 11
  SCE_PL_SCALAR = 12
  SCE_PL_ARRAY = 13
  SCE_PL_HASH = 14
  SCE_PL_SYMBOLTABLE = 15
  SCE_PL_REGEX = 17
  SCE_PL_REGSUBST = 18
  SCE_PL_LONGQUOTE = 19
  SCE_PL_BACKTICKS = 20
  SCE_PL_DATASECTION = 21
  SCE_PL_HERE_DELIM = 22
  SCE_PL_HERE_Q = 23
  SCE_PL_HERE_QQ = 24
  SCE_PL_HERE_QX = 25
  SCE_PL_STRING_Q = 26
  SCE_PL_STRING_QQ = 27
  SCE_PL_STRING_QX = 28
  SCE_PL_STRING_QR = 29
  SCE_PL_STRING_QW = 30
  ##
  # Lexical states for SCLEX_VB, SCLEX_VBSCRIPT
  SCE_B_DEFAULT = 0
  SCE_B_COMMENT = 1
  SCE_B_NUMBER = 2
  SCE_B_KEYWORD = 3
  SCE_B_STRING = 4
  SCE_B_PREPROCESSOR = 5
  SCE_B_OPERATOR = 6
  SCE_B_IDENTIFIER = 7
  SCE_B_DATE = 8
  ##
  # Lexical states for SCLEX_PROPERTIES
  SCE_PROPS_DEFAULT = 0
  SCE_PROPS_COMMENT = 1
  SCE_PROPS_SECTION = 2
  SCE_PROPS_ASSIGNMENT = 3
  SCE_PROPS_DEFVAL = 4
  ##
  # Lexical states for SCLEX_LATEX
  SCE_L_DEFAULT = 0
  SCE_L_COMMAND = 1
  SCE_L_TAG = 2
  SCE_L_MATH = 3
  SCE_L_COMMENT = 4
  ##
  # Lexical states for SCLEX_LUA
  SCE_LUA_DEFAULT = 0
  SCE_LUA_COMMENT = 1
  SCE_LUA_COMMENTLINE = 2
  SCE_LUA_COMMENTDOC = 3
  SCE_LUA_NUMBER = 4
  SCE_LUA_WORD = 5
  SCE_LUA_STRING = 6
  SCE_LUA_CHARACTER = 7
  SCE_LUA_LITERALSTRING = 8
  SCE_LUA_PREPROCESSOR = 9
  SCE_LUA_OPERATOR = 10
  SCE_LUA_IDENTIFIER = 11
  SCE_LUA_STRINGEOL = 12
  SCE_LUA_WORD2 = 13
  SCE_LUA_WORD3 = 14
  SCE_LUA_WORD4 = 15
  SCE_LUA_WORD5 = 16
  SCE_LUA_WORD6 = 17
  ##
  # Lexical states for SCLEX_ERRORLIST
  SCE_ERR_DEFAULT = 0
  SCE_ERR_PYTHON = 1
  SCE_ERR_GCC = 2
  SCE_ERR_MS = 3
  SCE_ERR_CMD = 4
  SCE_ERR_BORLAND = 5
  SCE_ERR_PERL = 6
  SCE_ERR_NET = 7
  SCE_ERR_LUA = 8
  SCE_ERR_CTAG = 9
  SCE_ERR_DIFF_CHANGED = 10
  SCE_ERR_DIFF_ADDITION = 11
  SCE_ERR_DIFF_DELETION = 12
  SCE_ERR_DIFF_MESSAGE = 13
  SCE_ERR_PHP = 14
  ##
  # Lexical states for SCLEX_BATCH
  SCE_BAT_DEFAULT = 0
  SCE_BAT_COMMENT = 1
  SCE_BAT_WORD = 2
  SCE_BAT_LABEL = 3
  SCE_BAT_HIDE = 4
  SCE_BAT_COMMAND = 5
  SCE_BAT_IDENTIFIER = 6
  SCE_BAT_OPERATOR = 7
  ##
  # Lexical states for SCLEX_MAKEFILE
  SCE_MAKE_DEFAULT = 0
  SCE_MAKE_COMMENT = 1
  SCE_MAKE_PREPROCESSOR = 2
  SCE_MAKE_IDENTIFIER = 3
  SCE_MAKE_OPERATOR = 4
  SCE_MAKE_TARGET = 5
  SCE_MAKE_IDEOL = 9
  ##
  # Lexical states for SCLEX_DIFF
  SCE_DIFF_DEFAULT = 0
  SCE_DIFF_COMMENT = 1
  SCE_DIFF_COMMAND = 2
  SCE_DIFF_HEADER = 3
  SCE_DIFF_POSITION = 4
  SCE_DIFF_DELETED = 5
  SCE_DIFF_ADDED = 6
  ##
  # Lexical states for SCLEX_CONF (Apache Configuration Files Lexer)
  SCE_CONF_DEFAULT = 0
  SCE_CONF_COMMENT = 1
  SCE_CONF_NUMBER = 2
  SCE_CONF_IDENTIFIER = 3
  SCE_CONF_EXTENSION = 4
  SCE_CONF_PARAMETER = 5
  SCE_CONF_STRING = 6
  SCE_CONF_OPERATOR = 7
  SCE_CONF_IP = 8
  SCE_CONF_DIRECTIVE = 9
  ##
  # Lexical states for SCLEX_AVE, Avenue
  SCE_AVE_DEFAULT = 0
  SCE_AVE_COMMENT = 1
  SCE_AVE_NUMBER = 2
  SCE_AVE_WORD = 3
  SCE_AVE_KEYWORD = 4
  SCE_AVE_STATEMENT = 5
  SCE_AVE_STRING = 6
  SCE_AVE_ENUM = 7
  SCE_AVE_STRINGEOL = 8
  SCE_AVE_IDENTIFIER = 9
  SCE_AVE_OPERATOR = 10
  ##
  # Lexical states for SCLEX_ADA
  SCE_ADA_DEFAULT = 0
  SCE_ADA_WORD = 1
  SCE_ADA_IDENTIFIER = 2
  SCE_ADA_NUMBER = 3
  SCE_ADA_DELIMITER = 4
  SCE_ADA_CHARACTER = 5
  SCE_ADA_CHARACTEREOL = 6
  SCE_ADA_STRING = 7
  SCE_ADA_STRINGEOL = 8
  SCE_ADA_LABEL = 9
  SCE_ADA_COMMENTLINE = 10
  SCE_ADA_ILLEGAL = 11
  ##
  # Lexical states for SCLEX_BAAN
  SCE_BAAN_DEFAULT = 0
  SCE_BAAN_COMMENT = 1
  SCE_BAAN_COMMENTDOC = 2
  SCE_BAAN_NUMBER = 3
  SCE_BAAN_WORD = 4
  SCE_BAAN_STRING = 5
  SCE_BAAN_PREPROCESSOR = 6
  SCE_BAAN_OPERATOR = 7
  SCE_BAAN_IDENTIFIER = 8
  SCE_BAAN_STRINGEOL = 9
  SCE_BAAN_WORD2 = 10
  ##
  # Lexical states for SCLEX_LISP
  SCE_LISP_DEFAULT = 0
  SCE_LISP_COMMENT = 1
  SCE_LISP_NUMBER = 2
  SCE_LISP_KEYWORD = 3
  SCE_LISP_STRING = 6
  SCE_LISP_STRINGEOL = 8
  SCE_LISP_IDENTIFIER = 9
  SCE_LISP_OPERATOR = 10
  ##
  # Lexical states for SCLEX_EIFFEL and SCLEX_EIFFELKW
  SCE_EIFFEL_DEFAULT = 0
  SCE_EIFFEL_COMMENTLINE = 1
  SCE_EIFFEL_NUMBER = 2
  SCE_EIFFEL_WORD = 3
  SCE_EIFFEL_STRING = 4
  SCE_EIFFEL_CHARACTER = 5
  SCE_EIFFEL_OPERATOR = 6
  SCE_EIFFEL_IDENTIFIER = 7
  SCE_EIFFEL_STRINGEOL = 8
  ##
  # Lexical states for SCLEX_NNCRONTAB (nnCron crontab Lexer)
  SCE_NNCRONTAB_DEFAULT = 0
  SCE_NNCRONTAB_COMMENT = 1
  SCE_NNCRONTAB_TASK = 2
  SCE_NNCRONTAB_SECTION = 3
  SCE_NNCRONTAB_KEYWORD = 4
  SCE_NNCRONTAB_MODIFIER = 5
  SCE_NNCRONTAB_ASTERISK = 6
  SCE_NNCRONTAB_NUMBER = 7
  SCE_NNCRONTAB_STRING = 8
  SCE_NNCRONTAB_ENVIRONMENT = 9
  SCE_NNCRONTAB_IDENTIFIER = 10
  ##
  # Lexical states for SCLEX_MATLAB
  SCE_MATLAB_DEFAULT = 0
  SCE_MATLAB_COMMENT = 1
  SCE_MATLAB_COMMAND = 2
  SCE_MATLAB_NUMBER = 3
  SCE_MATLAB_KEYWORD = 4
  SCE_MATLAB_STRING = 5
  SCE_MATLAB_OPERATOR = 6
  SCE_MATLAB_IDENTIFIER = 7
  ##
  # Lexical states for SCLEX_SCRIPTOL
  SCE_SCRIPTOL_DEFAULT = 0
  SCE_SCRIPTOL_COMMENT = 1
  SCE_SCRIPTOL_COMMENTLINE = 2
  SCE_SCRIPTOL_COMMENTDOC = 3
  SCE_SCRIPTOL_NUMBER = 4
  SCE_SCRIPTOL_WORD = 5
  SCE_SCRIPTOL_STRING = 6
  SCE_SCRIPTOL_CHARACTER = 7
  SCE_SCRIPTOL_UUID = 8
  SCE_SCRIPTOL_PREPROCESSOR = 9
  SCE_SCRIPTOL_OPERATOR = 10
  SCE_SCRIPTOL_IDENTIFIER = 11
  SCE_SCRIPTOL_STRINGEOL = 12
  SCE_SCRIPTOL_VERBATIM = 13
  SCE_SCRIPTOL_REGEX = 14
  SCE_SCRIPTOL_COMMENTLINEDOC = 15
  SCE_SCRIPTOL_WORD2 = 16
  SCE_SCRIPTOL_COMMENTDOCKEYWORD = 17
  SCE_SCRIPTOL_COMMENTDOCKEYWORDERROR = 18
  SCE_SCRIPTOL_COMMENTBASIC = 19
  ##
  # Lexical states for SCLEX_ASM
  SCE_ASM_DEFAULT = 0
  SCE_ASM_COMMENT = 1
  SCE_ASM_NUMBER = 2
  SCE_ASM_STRING = 3
  SCE_ASM_OPERATOR = 4
  SCE_ASM_IDENTIFIER = 5
  SCE_ASM_CPUINSTRUCTION = 6
  SCE_ASM_MATHINSTRUCTION = 7
  SCE_ASM_REGISTER = 8
  SCE_ASM_DIRECTIVE = 9
  SCE_ASM_DIRECTIVEOPERAND = 10
  ##
  # Lexical states for SCLEX_FORTRAN
  SCE_F_DEFAULT = 0
  SCE_F_COMMENT = 1
  SCE_F_NUMBER = 2
  SCE_F_STRING1 = 3
  SCE_F_STRING2 = 4
  SCE_F_STRINGEOL = 5
  SCE_F_OPERATOR = 6
  SCE_F_IDENTIFIER = 7
  SCE_F_WORD = 8
  SCE_F_WORD2 = 9
  SCE_F_WORD3 = 10
  SCE_F_PREPROCESSOR = 11
  SCE_F_OPERATOR2 = 12
  SCE_F_LABEL = 13
  SCE_F_CONTINUATION = 14

  ##
  # Events

  ##
  # GTK+ Specific to work around focus and accelerator problems:


  ##
  # CARET_POLICY changed in 1.47
  def set_caret_policy( caretPolicy , caretSlop )
    return (send_message(2369, caretPolicy, caretSlop))
  end
  CARET_CENTER = 0x02
  CARET_XEVEN = 0x08
  CARET_XJUMPS = 0x10

  ##
  # The old name for SCN_UPDATEUI
  SCN_CHECKBRACE = 2007

  module ScintillaEvents
    def handle_notification(from, id, scn)
      case id
      when 2000
        on_style_needed(scn.position)
      when 2001
        on_char_added(scn.ch)
      when 2002
        on_save_point_reached
      when 2003
        on_save_point_left
      when 2004
        on_modify_attempt_ro
      when 2005
        on_key(scn.ch, scn.modifiers)
      when 2006
        on_double_click
      when 2007
        on_update_ui
      when 2008
        on_modified(scn.position, scn.modificationType, scn.text, scn.length, scn.linesAdded, scn.line, scn.foldLevelNow, scn.foldLevelPrev)
      when 2009
        on_macro_record(scn.message, scn.wParam, scn.lParam)
      when 2010
        on_margin_click(scn.modifiers, scn.position, scn.margin)
      when 2011
        on_need_shown(scn.position, scn.length)
      when 2013
        on_painted
      when 2014
        on_user_list_selection(scn.listType, scn.text)
      when 2015
        on_uri_dropped(scn.text)
      when 2016
        on_dwell_start(scn.position)
      when 2017
        on_dwell_end(scn.position)
      when 2018
        on_zoom
      when 2012
        on_pos_changed(scn.position)
      end
    end
    def on_style_needed(position)
    end
    def on_char_added(ch)
    end
    def on_save_point_reached
    end
    def on_save_point_left
    end
    def on_modify_attempt_ro
    end
    def on_key(ch, modifiers)
    end
    def on_double_click
    end
    def on_update_ui
    end
    def on_modified(position, modification_type, text, length, lines_added, line, fold_level_now, fold_level_prev)
    end
    def on_macro_record(message, w_param, l_param)
    end
    def on_margin_click(modifiers, position, margin)
    end
    def on_need_shown(position, length)
    end
    def on_painted
    end
    def on_user_list_selection(list_type, text)
    end
    def on_uri_dropped(text)
    end
    def on_dwell_start(position)
    end
    def on_dwell_end(position)
    end
    def on_zoom
    end
    def on_pos_changed(position)
    end
  end
end
